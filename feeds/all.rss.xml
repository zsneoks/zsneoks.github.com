<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>木大</title><link>zsneoks.github.com/</link><description></description><atom:link href="zsneoks.github.com/feeds/all.rss.xml" rel="self"></atom:link><lastBuildDate>Thu, 05 Jul 2012 00:00:00 +0800</lastBuildDate><item><title>中子散射模拟</title><link>zsneoks.github.com/neutronScatterSim-htmlname.html</link><description>&lt;h3&gt;几何及其他物理参数&lt;/h3&gt;
&lt;p&gt;单位：mm&lt;/p&gt;
&lt;p&gt;CsI(Na): 25x25x25&lt;/p&gt;
&lt;p&gt;无氧铜： &amp;Phi;40x45&lt;/p&gt;
&lt;p&gt;铝膜： 三面，前，后，上。厚度0.1(?)&lt;/p&gt;
&lt;p&gt;石英壳： 内&amp;Phi;43 ,   厚度2  ,   高80&lt;/p&gt;
&lt;p&gt;外铝壳：外&amp;Phi;60   &lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;TOF: &amp;Phi;120x120  ,10厚度的塑闪包液闪，坐标距离中心探测器1000,角度选取符合5nKeV（n为整数）的核反冲能&lt;/p&gt;
&lt;p&gt;淬灭因子：0.2&lt;/p&gt;
&lt;p&gt;光产额： 40/KeV&lt;/p&gt;
&lt;p&gt;中子能量： 2.5MeV   DD，    14MeV   DT&lt;/p&gt;
&lt;p&gt;记录：PMT收集光子数，TOF中子计数，TOF中子及gamma的飞行时间&lt;/p&gt;
&lt;p&gt;附：使用最优的physicsList:LEB.hh中的new LEB&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Thu, 05 Jul 2012 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2012-07-05:neutronScatterSim-htmlname.html</guid><category>geant4</category><category>物理</category><category>高能</category><category>模拟</category></item><item><title>水池模拟</title><link>zsneoks.github.com/waterPoolSim.html</link><description>&lt;p&gt;1.模拟对比：&lt;/p&gt;
&lt;p&gt;先按原来几何，只改水池厚为1.8m模拟分析本底情况&lt;/p&gt;
&lt;p&gt;再将低温壁和无氧铜改为5cm的聚四氟乙稀模拟计算并进行对比&lt;/p&gt;
&lt;p&gt;2.计算中子穿过水池的效果&lt;/p&gt;
&lt;p&gt;计算出中子的剩余比例和能谱分布.&lt;/p&gt;
&lt;p&gt;3.问题
&lt;ul&gt;
 &lt;li&gt;&lt;s&gt;使用聚四氟乙稀方案下，水池壁的不锈钢是否有问题&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;水池壁改为水泥，模拟中相当于岩石了&lt;/li&gt; 
&lt;/ul&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Thu, 05 Jul 2012 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2012-07-05:waterPoolSim.html</guid><category>geant4</category><category>物理</category><category>高能</category><category>模拟</category></item><item><title>七月模拟</title><link>zsneoks.github.com/julyplan-htmlname.html</link><description>&lt;h4&gt;1.暗物质vetoPMT分布&lt;/h4&gt;
&lt;p&gt;通过改变PMT的分布和个数，研究PMT能收集到的光电子的多少，判断对muon子的探测能力。&lt;/p&gt;
&lt;h4&gt;2.&lt;a href="http://zsneoks.github.com/waterPoolSim.html"&gt;1.8m水池模拟&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;水1.8m.另模拟其他gamma本底及放射性中子本底。&lt;/p&gt;
&lt;h4&gt;3.alpha粒子的中子产额&lt;/h4&gt;
&lt;p&gt;模拟5.6MeV的alpha粒子入射塑料闪烁体的中子产出情况&lt;/p&gt;
&lt;h4&gt;4.&lt;a href="http://zsneoks.github.com/neutronScatterSim-htmlname.html"&gt;中子散射模拟&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;模拟记录信息：探测器中每次能量沉积的能量，位置，时间，粒子类型，物理过程&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Mon, 02 Jul 2012 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2012-07-02:julyplan-htmlname.html</guid><category>geant4</category><category>物理</category><category>高能</category><category>模拟</category></item><item><title>ApplicationRuntimeHandler及IRuntimeHandler文档解析</title><link>zsneoks.github.com/ApplicationRuntimeHandler-IRuntimeHandler-htmlname.html</link><description>&lt;h2&gt;ApplicationRuntimeHandlers&lt;/h2&gt;
&lt;p&gt;类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ApplicationRuntimeHandlers类图" src="images/applicationruntimehandlers.png" title="ApplicationRuntimeHandler类图" /&gt;&lt;/p&gt;
&lt;p&gt;文档解析：&lt;/p&gt;
&lt;p&gt;匹配app和backend的handlers机制。&lt;/p&gt;
&lt;h3&gt;1.add(self,application,backend,handler)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.get(self,application,backend)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.getAllBackends(self,application=None)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4.getAllApplication(self,backend=None)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;IRuntimeHandler&lt;/h2&gt;
&lt;p&gt;类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="IRuntimeHandler类图" src="images/iruntimehandler.png" /&gt;&lt;/p&gt;
&lt;p&gt;文档解析：&lt;/p&gt;
&lt;p&gt;RuntimeHandler是一个连接器，用来连接app和backend。app的configure方法产生appconfig对象。backend的submit方法使用jobconfig对象。RuntimeHandler将appconfig对象转换成jobconfig对象。该转换是作业提交的一部分。它在prepare方法中实现。&lt;/p&gt;
&lt;h3&gt;1.master_prepare(self,app,appmasterconfig)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为作业提交的共性（共享）部分做一些准备&lt;/li&gt;
&lt;li&gt;每个作业调用一次（包括要拆分作业或者不拆分的作业）&lt;/li&gt;
&lt;li&gt;返回值为backend可理解的jobmasterconfig对象&lt;/li&gt;
&lt;li&gt;参数
  &lt;ul&gt;
  &lt;li&gt;- app: 原始的app对象&lt;/li&gt;
  &lt;li&gt;- appmaster config:app.master_configure()的结果&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.prepare(self,app,appsubconfig,appmasterconfig,jobmasterconfig)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为作业提交的特性(子作业）部分做一些准备工作&lt;/li&gt;
&lt;li&gt;在拆分情况下每个子作业调用一次。&lt;/li&gt;
&lt;li&gt;如果没有拆分成子作业，则只调用一次&lt;/li&gt;
&lt;li&gt;返回值是backend可理解的subjobconfig对象的列表&lt;/li&gt;
&lt;li&gt;参数
  &lt;ul&gt;
  &lt;li&gt;- app: 原始的app对象&lt;/li&gt;
  &lt;li&gt;- appmaster config: app.master_configure()的结果&lt;/li&gt;
  &lt;li&gt;- appsubconfig:    app.configure()为每个子作业运行的结果的列表（不拆分的情况下则是主作业）&lt;/li&gt; 
  &lt;li&gt;- jobmasterconfig: self.master_prepare()的返回结果&lt;/li&gt;
  &lt;ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Thu, 28 Jun 2012 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2012-06-28:ApplicationRuntimeHandler-IRuntimeHandler-htmlname.html</guid><category>ganga</category><category>物理</category></item><item><title>IMerger及ISplitter文档解析</title><link>zsneoks.github.com/IMerger-ISplitter-htmlname.html</link><description>&lt;h2&gt;IMerger&lt;/h2&gt;
&lt;p&gt;类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="IMerger类图" src="images/imerger.png" title="IMerger类图" /&gt;&lt;/p&gt;
&lt;p&gt;文档解析：&lt;/p&gt;
&lt;h3&gt;1.merger(self,subjobs,sum_outputdir,**option)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;合并子作业的输出到sum_outputdir.&lt;/li&gt;
&lt;li&gt;options（关键字参数）由具体的子类定义&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.validatedMerge(self.job)&lt;/h3&gt;
&lt;h2&gt;ISplitter&lt;/h2&gt;
&lt;p&gt;类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ISplitter类图" src="images/isplitter.png" title="ISplitter类图" /&gt;&lt;/p&gt;
&lt;p&gt;文档解析：&lt;/p&gt;
&lt;h3&gt;1.split(self,job)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;根据主作业返回子作业列表&lt;/li&gt;
&lt;li&gt;主作业不会被更改&lt;/li&gt;
&lt;li&gt;具体子类必须实现本方法&lt;/li&gt;
&lt;li&gt;修改子作业的确定部分（如特定的属性）。子作业的其他部分都会相同。只有在schema中声明为"splitable"的属性才可修改。如果app handler不能处理被修改的参数，这个限定应用在app对象上就可以避免前后不一致。&lt;/li&gt;
&lt;li&gt;当前的实现中，backend的类型也不可更改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.validatedSplit(self,job)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;调用split()方法执行作业拆分，并使mutability inveriants有效&lt;/li&gt;
&lt;li&gt;如果invariants损坏(或者split()中发生异常），则抛出SplittingError异常&lt;/li&gt;
&lt;li&gt;由框架直接调用且不应该在子类中更改&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3._checksetNestedLists(self,value)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;检查嵌套列表，规则是如果有嵌套列表，则它不能包含GangaObjects，因为这会与repository冲突。不符合规则会抛出异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4.createSubjob(self,job)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;通过拷贝主作业来产生一个新的子作业，并正确设置其所有的域。&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Thu, 28 Jun 2012 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2012-06-28:IMerger-ISplitter-htmlname.html</guid><category>linux</category><category>ganga</category><category>物理</category></item><item><title>IApplication文档解析</title><link>zsneoks.github.com/IApplication-htmlname.html</link><description>&lt;p&gt;类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Iapp类图" src="./images/Iapp.png" title="Iapp类图" /&gt;&lt;/p&gt;
&lt;p&gt;是所有app对象的基类。子类在GPI中给出程序逻辑并从功能上实现配置操作。app配置是作业提交的第一步。&lt;/p&gt;
&lt;p&gt;实现配置方法的基本规则：&lt;/p&gt;
&lt;p&gt;一般configure()和master_configure()方法会在作业提交的时候调用，所以原则上你&lt;/p&gt;
&lt;p&gt;方法文档：&lt;/p&gt;
&lt;h3&gt;1.master_configure(self)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;配置app的共享（主要）方面。&lt;/li&gt;
&lt;li&gt;调用一次，splitting情况下也会调用&lt;/li&gt;
&lt;li&gt;返回元组(modified_flag, appconfig)
  &lt;ul&gt;
  &lt;li&gt; -appconfig(或appextra): 结构任意。由特定app运行时handler处理&lt;/li&gt;
  &lt;li&gt; -modified_flag: 如果configure()时对象self被改变了则为true&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果方法未实现则忽略掉&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.config(self,master_aapconfig)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;配置app的特定方面。与方法1有类似语义并且返回元组(modified_flag,appconfig).&lt;/li&gt;
&lt;li&gt;具体子类必须实现，否则作业提交（submission)会失败。&lt;/li&gt;
&lt;li&gt;参数master_configure是方法1的返回&lt;/li&gt;
&lt;li&gt;splitting情况下每个子作业对象调用一次。即有多少子作业就会调用多少次。&lt;/li&gt;
&lt;li&gt;无spliting情况下则会调用一次.&lt;/li&gt;
&lt;li&gt;从Ganga4.0.x开始，方法1被忽略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.postprocess(self)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;作业运行完后执行（即在报告作业状态为completed时）&lt;/li&gt;
&lt;li&gt;默认未做任何事&lt;/li&gt;
&lt;li&gt;可能抛出一个异常PostprocessStatusUpdate('faild').这种情况下作业状态是'failed'.但postprocess_failed()钩子不被调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4.postprocess_failed(self)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如字义作业报告为失败时调用。默认未做事&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5.transion_update(self,new_status)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在parent作业改变状态之前调用&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Mon, 25 Jun 2012 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2012-06-25:IApplication-htmlname.html</guid><category>ganga</category><category>物理</category></item><item><title>Ganga中文</title><link>zsneoks.github.com/gangadoc-html.html</link><description>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;link rel="Stylesheet" type="text/css" href="style.css"&gt;
&lt;title&gt;GangaDoc&lt;/title&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h3 id="toc_0.0.1" class="justcenter"&gt;&lt;a href="gangadoc/index.html"&gt;Ganga文档首页入口&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id="toc_0.0.1.1"&gt;3 实现&lt;/h4&gt;

&lt;blockquote&gt;
这章提供了GANGA中一些重要部分的当前实现细节。
&lt;/blockquote&gt;

&lt;h6 id="toc_0.0.1.1.0.1"&gt;3.1 组件&lt;/h6&gt;

&lt;blockquote&gt;
作业的各个组件以插件类的形式来实现，需用户在配置文件中设为enabled，则会由GANGA在启动时导入。这表示用户仅能看到与其特定工作环境相关的组件。
&lt;/blockquote&gt;

&lt;blockquote&gt;
插件维护十分简单，采用了一组内部接口和一个产生代理类的机制。组件类继承自接口类。每个插件类都定义了一个schema，用它描述插件的属性和指定类型（只读/读写/内部）、可见性以及相关的用户友好(user-convinence)的过滤器和语法快捷方式(shortcut)。
&lt;/blockquote&gt;

&lt;blockquote&gt;
与用户直接进行交互的不是插件类，而是一个自动产生的代理类，代理类在GPI中可见。代理类只包含插件类中的一些在schema中定义可见的属性以及选出用于导出的方法。插件和代理的层次（level)分离十分灵活。在GPI层插件的实现细节不可见；所有代理类都遵循相同的设计逻辑（例如按值拷贝copy-by-value)；持续性自动化，会话等级锁定透明。用这种方法，底层的内部的API就与用户层的GPI分离开。
&lt;/blockquote&gt;

&lt;blockquote&gt;
框架不强迫开发者支持app和backend的所有组合，只要支持有意义和有趣的组合即可。为便于管理这些组合，提出了submission handler的概念。sumission handler是app和backend组件的一个连接器。在提交时间，它将app的内部表示（representation)传送给特定backend可以接受的表示(representation)。这种策略允许完全(inherently)不同的backend和app的结合，而不需要强制一个lowest-common-denominator接口。
&lt;/blockquote&gt;

&lt;h6 id="toc_0.0.1.1.0.2"&gt;3.2 作业保持（persistence）&lt;/h6&gt;

&lt;blockquote&gt;
作业仓库在一个简单数据库中提供作业保持，以便任何之后的Ganga会话都可以访问所有之前定义的作业。每当在Ganga会话中定义一个作业，它就会被自动地存入这个数据库中。作业仓库还提供了一个bookkeeping系统用来根据metadata挑选特殊的作业。metadata包括以下一些参数如作业名称、app类型、要提交的backend类型、以及作业状态等。它可以根据需要轻松地进行扩展。
&lt;/blockquote&gt;

&lt;blockquote&gt;
GANGA同时支持本地和远程的作业仓库。在本地仓库的情况下，数据库存储在本地的文件系统中，它提供一个孤立的解决方案。在远程情况下，客户端访问AMGA metadata服务器。远程服务器基于网格证书提供与可信和授权用户的加密连接。表现测试中,两种仓库在每个用户高达10000个作业,每个下都仍旧表现出了良好的scalability，单个作业的平均生成时间大约是0.2秒。。。（各种好。。。）
&lt;/blockquote&gt;

&lt;blockquote&gt;
作业仓库考虑到插件组件中的schema的升级维护，还包含了一个提供schema迁移的机制。
&lt;/blockquote&gt;

&lt;h6 id="toc_0.0.1.1.0.3"&gt;3.3 输入输出文件&lt;/h6&gt;

&lt;blockquote&gt;
Ganga在作业工作区存储作业的输入输出文件。在当前的实现中使用了本地文件系统，并且有一个简单的接口允许在Ganga构架下透明地访问作业文件。这些文件在为每个作业分别指定的目录中存储，该目录有一些子目录来存储输入输出文件或者用于子作业。
&lt;/blockquote&gt;

&lt;blockquote&gt;
用户可以在文件系统中直接访问作业文件或者使用Ganga命令访问（如job.peek()).从内部来看，考虑到额外的工作区实现的琐碎的集成，Ganga通过一个简单的抽象层持有输入输出文件。测试表明。。。
&lt;/blockquote&gt;

&lt;blockquote&gt;
远程工作区和远程作业仓库的结合有效地生成了一个漫游的profile，相同的Ganga会话可以在多个位置访问，这有点类似于在一个IMAP服务器上访问e-mail信息的情况。
&lt;/blockquote&gt;

&lt;h4 id="toc_0.0.1.2"&gt;4 监测&lt;/h4&gt;

&lt;blockquote&gt;
Ganga提供了两种类型的监测：内部监测用作业进程信息来更新用户，外部监测处理来自第三方服务的信息。
&lt;/blockquote&gt;

&lt;h6 id="toc_0.0.1.2.0.1"&gt;4.1 内部监测&lt;/h6&gt;

&lt;blockquote&gt;
Ganga使用监测程序自动保存作业状态的变更历程，这个监测程序设计用来处理变化的backend响应次数和加载功能。每个backend被poll进一个不同的从pool中取出的thread中，同时有一个有效的机制来避免响应较慢的backend造成的死锁。poll rate可以对每个backend都有单独的设定。
&lt;/blockquote&gt;

&lt;blockquote&gt;
监测子系统也会保存权限证书的remaining有效性的历程，比如网格代理和Kerberos tokens.用户需要注意更新，而如果没有动作那么Ganga就会被置入状态，在该状态下操作需要有效证书会不可用。
&lt;/blockquote&gt;

&lt;h6 id="toc_0.0.1.2.0.2"&gt;4.2 外部监测&lt;/h6&gt;

&lt;p&gt;&lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Mon, 25 Jun 2012 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2012-06-25:gangadoc-html.html</guid><category>linux</category><category>ganga</category><category>物理</category><category>software</category></item><item><title>IBackend文档解析</title><link>zsneoks.github.com/ibackend-htmlname.html</link><description>&lt;p&gt;类图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="IBackend类图" src="./images/IBackend.png" title="IBackend类图" /&gt;&lt;/p&gt;
&lt;p&gt;文档解析：&lt;/p&gt;
&lt;h3&gt;1.setup(self)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Ganga.core服务启动时由每个作业调用的一个钩子。在监测子系统enabled之前调用。可以被backend用来进行一些特殊的setup(比如远程backned的ssh传输管道）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.master_submit(self,rjobs,subjobconfigs,masterjobconfig,keep_going=false)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;提交主作业和所有子作业&lt;/li&gt;
&lt;li&gt;masterjobconfig是共享的，单独的subjob配置在subjobconfig中定义&lt;/li&gt;
&lt;li&gt;单个作业（无split的提交也通过本方法执行。在这种情况下subjobconfig只包含一个元素——作业本身。&lt;/li&gt;
&lt;li&gt;默认实现是调用每个单独作业的submit()方法&lt;/li&gt;
&lt;li&gt;如果任何子作业fails则整个过程被忽略并抛出一个IncompleteSubmissionError&lt;/li&gt;
&lt;li&gt;子作业已经submit的保持submitted&lt;/li&gt;
&lt;li&gt;默认实现不处理masterjobconfig(因此子类中一般可以重写本方法）&lt;/li&gt;
&lt;li&gt;在IBackend_submit()中keep_going是可选的，用以允许不支持keep_going=True的backend实现，这些backend在某些情况下可能要调用IBackend.master_submit()来工作，这样就不需要重写本方法。很多情况中该参数并不重要，因此由开发维护人员决定是否启用对该参数的支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.submit(self,subjobconfig,master_input_sandbox)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;提交一个单独的作业。成功返回1&lt;/li&gt;
&lt;li&gt;master_input_sandbox是一个列表，内容为所有子作业共享的文件名单&lt;/li&gt;
&lt;li&gt;不直接由框架调用，只被master_submit()方法的默认实现调用。因此如果master_submit()可以实现对单作业的提交，则本方法是多余的。&lt;/li&gt;
&lt;li&gt;4.0.x后的变化
  &lt;ul&gt;
  &lt;li&gt;subjobconfig与老接口的jobconfig等效&lt;/li&gt;
  &lt;li&gt;jobid已经废弃将移除&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4.master_prepare(self,masterjobconfig)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;准备主作业（共享的沙盒文件）。由master_submit()调用三次。沙盒根据self._packed_input_sandbox标志（一个类属性）产生&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5.master_auto_resubmit(self,rjobs)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个钩子，在有人想重写自动resubmit行为时可以使用。否则等效于普通的resubmit。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;6.master_resubmit(self,rjobs,backend=None)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;resubmit(状态是submitted的）作业。&lt;/li&gt;
&lt;li&gt;配置phase会跳过。&lt;/li&gt;
&lt;li&gt;默认的实现是一个等效bulk的操作&lt;/li&gt;
&lt;li&gt;如果重写，要保证在主作业上调用过updateMasterJobstatus()，以使主作业能监控循环上被监控。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;7.master_kill(self)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;kill作业和所有子作业。成功返回1.&lt;/li&gt;
&lt;li&gt;默认的实现是使用kill()方法并在所有子作业上仿照bulk操作&lt;/li&gt;
&lt;li&gt;在有failure的情况下依然会尽可能多的kill掉子作业。&lt;/li&gt;
&lt;li&gt;若操作未完成则抛出IncompleteKillError()异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;8.kill(self)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;kill作业（和所有子作业）&lt;/li&gt;
&lt;li&gt;从不会由框架调用。只会被默认的master_kill()调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;9.peek(self,filename='',command='')&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;允许查看作业在backend上的输出文件&lt;/li&gt;
&lt;li&gt;由command命令查看filename文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;10.remove(self)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;主要用于远程(ssh)backend.当作业被移除的时候这个backend方法被调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;11.master_updateMonitoringInformation(jobs)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态方法&lt;/li&gt;
&lt;li&gt;更新作业的监控信息：
  &lt;ul&gt;
  &lt;li&gt;在Backendk需要监控的作业列表（包括状态为submitted和running的作业）&lt;/li&gt;
  &lt;li&gt;上述作业列表中不包含子作业&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;默认实现是叠代遍历子作业并执行updateMonitoringInformation()&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;12.updateMonitoringInformation(jobs)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态方法&lt;/li&gt;
&lt;li&gt;更新单作业的监控信息。这个作业是指一个作业列表，可包含子作业和无分片作业&lt;/li&gt;
&lt;li&gt;框架中不会直接调用。可能仅由master_updateMonitoringInformation()默认实现来调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;13.timedetails(self)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;返回所有可用的backend指定的时间戳&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;14.getStateTime(self,status)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在作业转变到running和completed状态时取得时间戳&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;15.check_auto_resubmit(self)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个钩子，用于检查作业是否能自动resubmitted.&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Mon, 25 Jun 2012 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2012-06-25:ibackend-htmlname.html</guid><category>linux</category><category>ganga</category><category>物理</category></item><item><title>new test</title><link>zsneoks.github.com/new-test.html</link><description>&lt;p&gt;Just a new test&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Sun, 24 Jun 2012 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2012-06-24:new-test.html</guid><category>test</category></item><item><title>测试snip</title><link>zsneoks.github.com/testsnip-htmlname.html</link><description>&lt;p&gt;test test 
test test 
test test 
test test 
test test 
test test 
test test 
test test &lt;/p&gt;
&lt;p&gt;test test &lt;/p&gt;
&lt;p&gt;test test &lt;/p&gt;
&lt;p&gt;test test &lt;/p&gt;
&lt;p&gt;test test &lt;/p&gt;
&lt;p&gt;test test &lt;/p&gt;
&lt;p&gt;test test &lt;/p&gt;
&lt;p&gt;test test &lt;/p&gt;
&lt;p&gt;test test &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Sun, 24 Jun 2012 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2012-06-24:testsnip-htmlname.html</guid><category>test</category><category></category></item><item><title>理论物理学的方法--狄拉克</title><link>zsneoks.github.com/physics-method.html</link><description>&lt;p&gt;发信人: Bessel ( Bessel), 信区: Physics &lt;/p&gt;
&lt;p&gt;标 题: 理论物理学的方法－－狄拉克 &lt;/p&gt;
&lt;p&gt;发信站: BBS 科苑星空站 (Tue Apr 4 14:03:57 2006), 站内 &lt;/p&gt;
&lt;p&gt;理论物理学的方法 &lt;/p&gt;
&lt;p&gt;[狄拉克（1902—1984），英国物理学家。生于布里斯托尔。1926年获剑桥大学哲学博士学位，1932年成为该校教授。1930年选为英国皇家学会会员。他在描述原子现象的量子力学方面有较大贡献。他提出了相对论形式的薛定谔基本方程，即狄拉克方程。在理论上曾预测到正电子。1933年他与薛定谔因建立新型原子理论而同获诺贝尔物理学奖。] &lt;/p&gt;
&lt;p&gt;我打算与你们谈谈一个理论物理学家是如何工作——他是怎样着手尝试去更好地理解自然规律的。 &lt;/p&gt;
&lt;p&gt;一个人能回顾他过去所做的工作。这时他心中有个基本希望，希望他可以得到一些在处理目前的问题时有价值的启示或教训。我们过去必须处理的问题与今天的问题在根本上有很多相同之处，评论一下过去成功的方法对目前的工作可以有所帮助。 &lt;/p&gt;
&lt;p&gt;理论物理学家的工作程序可以分成两大类。其一是在实验基础上开始工作。为此，必须与实验物理学家们保持密切的接触，知悉他们得到的全部结果而试图使这些结果适合一个全面的令人满意的图式。 &lt;/p&gt;
&lt;p&gt;另一种程序是在数学基础上着手工作，考察并批判现在的理论，设法确认其中的错误，然后努力消除它。这里的困难在于要消除这些错误而又不破坏现存理论的巨大成功。 &lt;/p&gt;
&lt;p&gt;存在着这样两种普遍程序。当然，它们之间的差别不是一成不变的。在两个极端之间有各种等级的程序。 &lt;/p&gt;
&lt;p&gt;遵循哪一种程序在很大程度上取决于研究的课题。对于一个不甚了解的课题，人们正在那里开辟完全新的天地，他们完全被迫遵循依据实验的程序。对于一个新的课题，人们起初仅仅收集实验证据并对它们进行分类。 &lt;/p&gt;
&lt;p&gt;例如，让我们回想一下上一世纪我们所确立的元素周期表的知识是怎样积累的吧。开始，人们只是收集材料并对它们进行整理。随着周期表的建立，人们才逐渐得以相信它。到最后，在周期表接近完成时，人们完全有把握预言，哪里有空白，以后会发现一种新原子来填补这一空白。这些预言全部实现了。 &lt;/p&gt;
&lt;p&gt;当前，关于高能物理学的新粒子存在着一种十分相似的情形。这些粒子已经填进一个表，人们对这个体系是那么相信，以致一旦发现有空白，就能预言将发现一种粒子来填补它。 &lt;/p&gt;
&lt;p&gt;在物理学的每个被了解得很少的领域中，如果人们不想沉湎于几乎肯定是错误的荒唐的推测的话，就必须固守实验基础。我并不想一概而论地责备推测。它可能是有趣的，或许是间接有用的，即使它的结果是错误的。人们总应保持开放的头脑来接受新思想，因此人们不应该完全反对推测。但必须小心，不能过于陷入推测。 &lt;/p&gt;
&lt;p&gt;我要提一下，我发现最好的想法通常并不是在人们积极寻求它们时得来的，而是在人们处于放松状态时得来的。布洛克教授曾对我们说过他如何在火车上捕获一些想法，而且常在旅行结束之前完成这些想法。我却不是这样，我常在星期天独自长途散步，散步时，我往往以悠闲的方法去回顾当前的情形。这种场合常常证明是富有成果的，虽然散步的目的在于休息而不在于探索。 &lt;/p&gt;
&lt;p&gt;正是在一次这样的场合中，我想到在对易子和泊松符号之间的联系的可能性。我并不十分了解泊松符号是什么，因此不能确定这个联系。到家后我发现，我那里没有一本书解释了泊松符号，因此我不得不焦急地等待第二天早上图书馆开门，我要证实这个想法。 &lt;/p&gt;
&lt;p&gt;原子物理学的最终目标是得到合适的初始方程，由此可推演出整个原子物理学。我们距此还很远，向这个目标前进的第一步是完成低能物理学理论，这就是量子电动力学，然后推广到越来越高的能量。但目前的量子电动力学不能适应数学美的高标准，我们期望基本物理理论有这种数学美。目前的量子电动力学还使人觉得，仍然需要在基本思想上有激烈的变革。 &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Tue, 10 Jan 2012 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2012-01-10:physics-method.html</guid><category>物理</category><category>方法</category><category>学术</category></item><item><title>vim插件备份</title><link>zsneoks.github.com/vim-backup.html</link><description>&lt;p&gt;vimrepress&lt;/p&gt;
&lt;p&gt;a.vim&lt;/p&gt;
&lt;p&gt;tagbar&lt;/p&gt;
&lt;p&gt;neocomplcache&lt;/p&gt;
&lt;p&gt;matchit&lt;/p&gt;
&lt;p&gt;xml.vim&lt;/p&gt;
&lt;p&gt;omnicppcomplete&lt;/p&gt;
&lt;p&gt;auto.vim&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Sat, 10 Sep 2011 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2011-09-10:vim-backup.html</guid><category>vim</category></item><item><title>庆祝终端与fcitx相安无事</title><link>zsneoks.github.com/terminal-fcitx.html</link><description>&lt;p&gt;如题。此帖专为庆祝fcitx终于不再与gtk3打架了。以后可以相安无事了。&lt;/p&gt;
&lt;p&gt;休息！~&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Mon, 22 Aug 2011 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2011-08-22:terminal-fcitx.html</guid><category>linux</category><category>fcitx</category></item><item><title>geant4核反冲模拟结论小记</title><link>zsneoks.github.com/geant4-neclear-summary.html</link><description>&lt;p&gt;一、中子散射产生的反冲核均为裸核。即带电量是核电荷数，也即原子序数。&lt;/p&gt;
&lt;p&gt;二、反冲核电离产生的电子能量很低（至少低于250eV,此为geant4模拟中的阈值），不足以继续电离出次级粒子。(这里的说法还有问题)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Thu, 11 Aug 2011 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2011-08-11:geant4-neclear-summary.html</guid><category>geant4</category><category>模拟</category><category>高能</category></item><item><title>学术搜索引擎-转载</title><link>zsneoks.github.com/search-engine.html</link><description>&lt;p&gt;1、&lt;a href="http://cholar.google.com"&gt;http://scholar.google.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个不多讲了. ­&lt;/p&gt;
&lt;p&gt;2、http://qns.cc/ ­­&lt;/p&gt;
&lt;p&gt;后起之秀，科研人员的良好助手，上此网站的90%是从事科研的学生与老师。其词典搜索集成了目前市面上最好的在线英汉写作及科研词典，用此搜索引擎写作英文论文相当方便；其文献搜索集成了目前最优秀的数据库。­&lt;/p&gt;
&lt;p&gt;3、http://www.scirus.com ­&lt;/p&gt;
&lt;p&gt;Scirus是目前互联网上最全面、综合性最强的科技文献搜索引擎之一，由Elsevier科学出 ­&lt;/p&gt;
&lt;p&gt;版社开发，用于搜索期刊和专利，效果很不错！Scirus覆盖的学科范围包括：农业与生物 ­&lt;/p&gt;
&lt;p&gt;学，天文学，生物科学，化学与化工，计算机科学，地球与行星科学，经济、金融与管理 ­&lt;/p&gt;
&lt;p&gt;科学，工程、能源与技术，环境科学，语言学，法学，生命科学，材料科学，数学，医学 ­&lt;/p&gt;
&lt;p&gt;，神经系统科学，药理学，物理学，心理学，社会与行为科学，社会学等。 ­­&lt;/p&gt;
&lt;p&gt;4、http://www.base-search.net/ ­&lt;/p&gt;
&lt;p&gt;BASE是德国比勒费尔德(Bielefeld)大学图书馆开发的一个多学科的学术搜索引擎，提供对 ­&lt;/p&gt;
&lt;p&gt;全球异构学术资源的集成检索服务。它整合了德国比勒费尔德大学图书馆的图书馆目录和 ­&lt;/p&gt;
&lt;p&gt;大约160 个开放资源（超过200 万个文档）的数据。 ­­&lt;/p&gt;
&lt;p&gt;5、http://www.vascoda.de/ ­&lt;/p&gt;
&lt;p&gt;Vascoda是一个交叉学科门户网站的原型，它注重特定主题的聚合，集成了图书馆的收藏、 ­&lt;/p&gt;
&lt;p&gt;文献数据库和附加的学术内容。 ­­&lt;/p&gt;
&lt;p&gt;6、http://www.goole.com/ ­&lt;/p&gt;
&lt;p&gt;与google比较了一下发现，能搜索到一些google搜索不到的好东东 。它界面简洁，功能强 ­&lt;/p&gt;
&lt;p&gt;大，速度快，YAHOO、网易都采用了它的搜索技术。各位可以一试。 ­­&lt;/p&gt;
&lt;p&gt;7、 http://www.a9.com ­&lt;/p&gt;
&lt;p&gt;Google在同一水平的搜索引擎。是Amazon.com推出的，Web result部分是基于Google的， ­&lt;/p&gt;
&lt;p&gt;所以保证和Google在同一水平，另外增加了Amazon的在书本内搜索的功能和个性化功能： ­&lt;/p&gt;
&lt;p&gt;主要是可以记录你的搜索历史。现在还是Beta，不过试用后感觉很好，向大家推荐一试 ， ­&lt;/p&gt;
&lt;p&gt;不过缺憾是现在书本内搜索没有中文内容。 ­&lt;/p&gt;
&lt;p&gt;8、http://www.ixquick.com ­&lt;/p&gt;
&lt;p&gt;严格意义上讲不是搜索引擎，是连接搜索引擎和网络用户的信息立交桥。新一代的搜索引 ­&lt;/p&gt;
&lt;p&gt;擎应运而生，Ixquick meta－search正是目前最具光芒的新星。但是对于大多数国内用户 ­&lt;/p&gt;
&lt;p&gt;来说，Ixquick还很陌生。Ixquick众多独特的功能我不一一介绍了，只介绍我们最关心的 ­&lt;/p&gt;
&lt;p&gt;，搜索数据库密码。 ­&lt;/p&gt;
&lt;p&gt;使用方法：先进入Ixquick，以“Proquest”数据库为例。填入Proquest Username Passw­&lt;/p&gt;
&lt;p&gt;ord History Online后点击search，看看出来的结果，第一页中第6个，proquest的usern ­&lt;/p&gt;
&lt;p&gt;ame和password赫然在目，别急，再看第4个结果“HB Thompson Subscription Online Databases”，即http://homework.syosset.k12.ny.us/onlinedbs/HBTDatabases/，进入后 ­发现这是一个密码页，选择Magazines &amp;amp; Journals栏，就有 EBSCO、Electric Library Elementary、Electric Library Elementary、ProQuest Platinum (in school)、ProQues t Platinum (remote)等众多数据库的密码，都有uesrname和password，随便试一下EBSCO ­，OK，成功登陆。 ­&lt;/p&gt;
&lt;p&gt;9、http://vivisimo.com/ ­&lt;/p&gt;
&lt;p&gt;cmu的作品，对搜索的内容进行分类，这样可以有效地做出选择，比较有特色。可实现分类 ­&lt;/p&gt;
&lt;p&gt;检索，检索速度也很好，如EBSCO 密码几分钟就可找一大堆 . ­&lt;/p&gt;
&lt;p&gt;http://search.epnet.com/ ­&lt;/p&gt;
&lt;p&gt;User ID: mountain ­&lt;/p&gt;
&lt;p&gt;Password: ridge ­&lt;/p&gt;
&lt;p&gt;这个密码可以试试。 ­&lt;/p&gt;
&lt;p&gt;­&lt;/p&gt;
&lt;p&gt;10、http://www.findarticles.com/ ­&lt;/p&gt;
&lt;p&gt;一个检索免费paper的好工具。 进入网页以后，可以看到他有三个功能，driectory web ­&lt;/p&gt;
&lt;p&gt;article ，其中article对我们很有帮助，你可以尝试输入你要找的文章，会有很多发现的！ ­&lt;/p&gt;
&lt;p&gt;­&lt;/p&gt;
&lt;p&gt;11、http://www.sciseek.com/Sample ­&lt;/p&gt;
&lt;p&gt;感觉不是很好用，内容也不是太多，主要靠用户添加网址，提供信息的搜索引擎，搜索功 ­&lt;/p&gt;
&lt;p&gt;能也比较差，输入常见的关键词，往往找不到相匹配的内容。 ­&lt;/p&gt;
&lt;p&gt;­&lt;/p&gt;
&lt;p&gt;12、http://www.chmoogle.com ­&lt;/p&gt;
&lt;p&gt;现点击后或跳转到http://www.emolecules.com，在此搜索引擎里可以搜索到超过千万种化学品信息或相应的供应商，与Chemblink有点相似，但提供的化学品理化信息没有Chemblink详细，与其不同的是该搜索引擎可提供化学品结构式搜索（主页上有在线绘制化学结构式的搜索框）。 ­&lt;/p&gt;
&lt;p&gt;13、 http://www.ojose.com/ ­&lt;/p&gt;
&lt;p&gt;OJOSE (Online Journal Search Engine，在线期刊搜索引擎)是一个强大的免费科学搜索 ­&lt;/p&gt;
&lt;p&gt;引擎，通过OJOSE，你能查找、下载或购买到近60个数据库的资源。但是感觉操作比较复杂。 ­&lt;/p&gt;
&lt;p&gt;­&lt;/p&gt;
&lt;p&gt;14、http://citeseer.ist.psu.edu/ ­&lt;/p&gt;
&lt;p&gt;一个关于计算机和信息科学的搜索引擎。 ­&lt;/p&gt;
&lt;p&gt;­&lt;/p&gt;
&lt;p&gt;15、http://hpsearch.uni-trier.de/ ­&lt;/p&gt;
&lt;p&gt;专家个人主页搜索引擎 ­&lt;/p&gt;
&lt;p&gt;­&lt;/p&gt;
&lt;p&gt;16、http://cnplinker.cnpeak.com/ ­&lt;/p&gt;
&lt;p&gt;为了给读者用户提供一个方便快捷的查阅国外各类期刊文献的综合网络平台，中图公司组 ­&lt;/p&gt;
&lt;p&gt;织开发了cnpLINKer（cnpiec LINK service）在线数据库检索系统，并正式开通运行。cn ­&lt;/p&gt;
&lt;p&gt;pLINKer即“中图链接服务”，目前主要提供约3600种国外期刊的目次和文摘的查询检索、­&lt;/p&gt;
&lt;p&gt;电子全文链接及期刊国内馆藏查询功能.并时时与国外出版社保持数据内容的一致性和最新 ­&lt;/p&gt;
&lt;p&gt;性. ­&lt;/p&gt;
&lt;p&gt;点评：只提供了外文检索的功能，但是无法得到全文。个人认为不是很理想。 ­&lt;/p&gt;
&lt;p&gt;­&lt;/p&gt;
&lt;p&gt;17、http://guoxue.baidu.com/ ­&lt;/p&gt;
&lt;p&gt;百度国学目前能提供上起先秦、下至清末历代文化典籍的检索和阅读。内容涉及经、史、 ­&lt;/p&gt;
&lt;p&gt;子、集各部。­&lt;/p&gt;
&lt;p&gt;18、http://infomine.ucr.edu/ ­&lt;/p&gt;
&lt;p&gt;NFOMIN是由加州大学、维克森林大学、加州国立大学、底特律大学等大学图书管理员建立 ­&lt;/p&gt;
&lt;p&gt;的学术搜索引擎。它主要为大学职员、学生和研究人员提供在线学术资源&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Thu, 11 Aug 2011 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2011-08-11:search-engine.html</guid><category>学术</category><category>搜索</category></item><item><title>Geant4模拟总结（二）</title><link>zsneoks.github.com/Geant4-sim-teach2.html</link><description>&lt;p&gt;今天要讲的主要是DetectorConstructor的编写。&lt;/p&gt;
&lt;p&gt;首先介绍下神马是DetectorConstructor。我们知道唱戏先得搭台子。创建编写DetectorConstructor类就是为模拟搭戏台舞台。比如你要模拟中子穿过晶体的过程。那么你首先得摆一块晶体。要摆一块晶体，除非你已经有一块形状尺寸材料都很理想的晶体了，然后你可以把它摆到某一个位置，放到位置后还可以再转一转方向什么的。否则，你就得自己去定义一块晶体出来，就像上边提到的，定义出晶体的材料、形状、尺寸。然后你就可以把这块晶体放到你想放置的位置了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;，定义材料。比如你想用的材料是纯CsI材料。你要先定义Cs原子和I原子。你可以像这样来定义：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;G4Element&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;elementCs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;G4Element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Cesium&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Cs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;55&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;132.90543&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mole&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;G4Element&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;elementI&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;G4Element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Iodine&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;53&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;126.90447&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mole&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们知道，上边的c++代码的语义是：第一行，创建一个指针elementCs，指向一个G4Element类的对象，并初始化该对象。构造函数中使用了四个参数，前两个字符串是该对象代表的原子的名称和简写。第三个参数是该原子的原子充数A，第四个是该原子的摩尔质量。这样，第一行就定义了Cs原子。同样的方法第二行代码定义了I原子。
之后，我们就可以用定义好的两种原子来定义纯CsI这种材料。代码：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;G4Material&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;CsI&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
    &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;G4Material&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;CsI&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;4.51&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cm3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kStateUndefined&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;273.15&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;kelvin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;atmosphere&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;CsI&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;AddElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;elementI&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;CsI&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;AddElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;elementCs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第一行代码，创建一个指针CsI，指向一个G4Material类的对象，并用一些参数来初始化该对象。构造函数中使用了六个参数。分别是名称、密度、几种成份（在这里是表示有两种原子）、状态（气态、液态、未定义等）、温度、压强。其中状态定义为未定，则Geant4可自行通过密度压强以及温度等参数计算其状态。后两行代码则表示这种材料的两种成份是什么。这里说明是前边我们定义的elementI和elementCs，并且原子个数比例是1：1。&lt;/p&gt;
&lt;p&gt;经过这两段代码我们就定义出来可以后边使用的取名为CsI的材料。我们后边可以使用CsI这个指针来调用这种材料。&lt;/p&gt;
&lt;p&gt;然后，我们还要定义晶体的尺寸和形状。比如我们要定义成立方体。立方体的类是G4Box。我们先用下边一行代码定义一个边长2.5cm的立方体。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;G4Box&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;  &lt;span class="n"&gt;solidCsI_log&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;G4Box&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;solidCsI_log&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;1.25&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.25&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.25&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cm&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上边代码的四个参数分别是名称和立方体的半长、半高、半宽（对应x、y、z三个坐标）。&lt;/p&gt;
&lt;p&gt;之后，我们把材料和形状合在一起，合成一个包含材料和形状信息的CsI晶体实体，我们叫它几何体(或者LogicalVolume)。代码：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;G4LogicalVolume&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;CsI_log&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;G4LogicalVolume&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;solidCsI_log&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;   &lt;span class="sr"&gt;//i&lt;/span&gt;&lt;span class="n"&gt;ts&lt;/span&gt; &lt;span class="n"&gt;shape&lt;/span&gt;
        &lt;span class="n"&gt;CsI&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;        &lt;span class="sr"&gt;//i&lt;/span&gt;&lt;span class="n"&gt;ts&lt;/span&gt;  &lt;span class="n"&gt;materical&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;CsI_log&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sr"&gt;//i&lt;/span&gt;&lt;span class="n"&gt;ts&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
        &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="sr"&gt;//&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;self&lt;/span&gt; &lt;span class="n"&gt;coordinate&lt;/span&gt; &lt;span class="nb"&gt;system&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，CsI_log就已经是我们定义好的一块完整的晶体了。我们现在用下边的代码把它摆放到世界中:   &lt;br /&gt;
&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;G4PhysicalVolume&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;CsI_phy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;G4PVPlacement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;G4ThreeVector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cm&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="n"&gt;CsI_log&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;         &lt;span class="sr"&gt;//i&lt;/span&gt;&lt;span class="n"&gt;ts&lt;/span&gt; &lt;span class="n"&gt;logical&lt;/span&gt; &lt;span class="n"&gt;volume&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;CsI_phy&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;      &lt;span class="sr"&gt;//i&lt;/span&gt;&lt;span class="n"&gt;ts&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;    
        &lt;span class="n"&gt;World_log&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;      &lt;span class="sr"&gt;//i&lt;/span&gt;&lt;span class="n"&gt;ts&lt;/span&gt; &lt;span class="n"&gt;mother&lt;/span&gt; &lt;span class="n"&gt;volume&lt;/span&gt;
        &lt;span class="n"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;          &lt;span class="sr"&gt;//&lt;/span&gt;&lt;span class="nb"&gt;no&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;operation&lt;/span&gt;
        &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;             &lt;span class="sr"&gt;//co&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Tue, 02 Aug 2011 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2011-08-02:Geant4-sim-teach2.html</guid><category>geant4</category><category>模拟</category></item><item><title>Geant4模拟总结(一)</title><link>zsneoks.github.com/Geant4-1.html</link><description>&lt;p&gt;笔者是Geant4的初学者，在Geant4学习过程中经历了一段只有例程为师的“痛苦”历程（据说学习Geant4的各位前辈都经历过相同的磨练，并毅然决定把这种心灵与肉体的双重磨砺传播发扬下去。于是在神功初成之后就果断归隐山林，从此不为世人所知。=.- :)）。&lt;/p&gt;
&lt;p&gt;在摸索学习Geant4三个月后，笔者对Geant4的使用建立了初步基本的认识。一方面想整理自己对Geant4基本使用方法的粗浅认识，更好的组织和精练自己的知识系统；另一方面也想总结分享下自己学习Geant4的过程和方法以及一些体会，但愿能为后来的Geant4初学者提供绵薄微助。于是有了写这个系列博文的想法。（其实你能看到这些东西还有一个更大的原因，那就是笔者最近迷上了用wordpress写博客=.=!)&lt;/p&gt;
&lt;p&gt;本文正如题目所说，是针对没有任何Geant4基础的初学者。不过笔者暂时还没有写如何安装Geant4的教程的想法。笔者也不打算普及计算机教育，默认读者有C++编程基础（如果你还不能阅读C++代码，那还是快先去学一学C++，不用对C++有多么深刻的体会和丰富的实践经验，你只要能读懂一个由数个或者十数个C++类写成的简单C++程序即可），因为Geant4是用C++编写的，你要在Geant4基础上开发模拟程序也要使用C++语言。(鉴于笔者的人生经验尚十分不丰富，如有出现不懂C++却依然能学好Geant4的，纯属奇迹，不管你信不信，反正笔者信；或者说，你丫就是天才！）&lt;/p&gt;
&lt;p&gt;好言归正传！&lt;/p&gt;
&lt;p&gt;先概括讲一下笔者对Geant4的整体印象。初识Geant4（就是半年前），是因为笔者的本科毕业设计是模拟宇宙线的一个小题目。还没怎么开始做，指导老师量才为用就中途给换了题目（为了能更好的锻炼我以及其他一些原因，老师让我转去做一些物理软件相关的develop编程工作），于是就放下了。可是不久之后由于另一个新项目软件模拟方面的人手不够我于是被转手，又再度回到了Geant4上来。真可谓一波三折。&lt;/p&gt;
&lt;p&gt;刚接触Geant4的时候笔者真是为这个类库深度折服和惊叹拍手（笔者当时当场欢呼起来，心里唯一的感受就是不可思议）。从一个用户的角度去看，这个类库的设计使它的使用方法真是绝妙方便和简单。它把一切都设计好了，你不需要想你的模拟要从哪里开始怎么开始如何进行，不需要去设计模拟的结构算法，不需要去思考用什么框架架构，因为这一切Geant4都已经为你设计好了。你只需要告诉Geant4你模拟的实验装置的几何形状尺寸位置以及材料等等几个参数，再告诉Geant4模拟中可能会出现的物理过程和粒子，然后给Geant4初始事例，然后再在适当的实验装置上放上眼睛（敏感探测器SD），最后做为牛顿的上帝你再轻轻伸出手指给你的模拟那个神秘的第一推动力，OK！你的模拟就完成了。你几乎不需要任何计算机方面的专业知识（看懂和编写C++代码除外）。而且，几乎所有的物理过程和粒子Geant4都已经为你写好了，你使用的时候只需要为程序提供相关过程和粒子的名称即可（这叫注册）。&lt;/p&gt;
&lt;p&gt;Geant4的使用就是这么简单！好了，今天先到这里。因为我要去吃饭了！~.~&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Fri, 29 Jul 2011 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2011-07-29:Geant4-1.html</guid><category>geant4</category><category>模拟</category><category>学术</category></item><item><title>test</title><link>zsneoks.github.com/test2.html</link><description>&lt;p&gt;\ \ \ \ 测试段首空格。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Fri, 29 Jul 2011 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2011-07-29:test2.html</guid><category>test</category></item><item><title>MarkDown常用语法</title><link>zsneoks.github.com/markdown-syntax.html</link><description>&lt;p&gt;纯为自己记录留用。主要选择自己现在初学者迫切需要的语法。日后熟悉了继续发展。&lt;/p&gt;
&lt;p&gt;1、空一行（两个回车）分段&lt;/p&gt;
&lt;p&gt;2、行末加两个或多个空格才是真正的换行，否则正常的一个回车就像在HTML代码中一样，被当作空
格处理 (很明显，我机器上并非如此，一个回车也被当回车入理了） &lt;br /&gt;
3、插入链接：&lt;a href="url"&gt;链接文字&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、图片跟链接很像，在前面加个叹号：！[alt 文字］(图片URL)&lt;/p&gt;
&lt;h2&gt;标题&lt;/h2&gt;
&lt;p&gt;用1-6个井号（＃）开始一行表示这一行是标题，倒如：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#一级标题&lt;/span&gt;
&lt;span class="c"&gt;##二级标题&lt;/span&gt;
&lt;span class="c"&gt;######六级标题&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;h1&gt;一级标题&lt;/h1&gt;
&lt;h2&gt;二级标题&lt;/h2&gt;
&lt;h6&gt;六级标题&lt;/h6&gt;
&lt;/blockquote&gt;
&lt;h2&gt;blockquote&lt;/h2&gt;
&lt;p&gt;用右尖括号（&amp;gt;）表示blockquote，你一定见过邮件中这样表示引用别人的内容。可以嵌套，可以包含其它的Markdown元素，例如：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="c1"&gt;## This is a header.&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;   &lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;   &lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Here&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt; &lt;span class="n"&gt;code:&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;shell_exec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;echo $input | $markdown_script&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;h2&gt;This is a header.&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;This is the first list item.&lt;/li&gt;
&lt;li&gt;This is the second list item.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here's some example code:&lt;/p&gt;
&lt;p&gt;return shell_exec("echo $input | $markdown_script");&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Thu, 28 Jul 2011 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2011-07-28:markdown-syntax.html</guid><category>linux</category><category>markdown</category></item><item><title>光学过程模拟方法细节promote</title><link>zsneoks.github.com/photon-sim-promote.html</link><description>&lt;p&gt;光学过程细节要考虑淬灭因子，且原子核淬灭与阿尔法粒子与电子（几乎无淬灭）的淬灭因子都不同。要在physicalList中重写不同粒子的闪烁过程，计算闪烁光子数时分别乘上不同的淬灭因子。详细闪烁过程的编写参考G4dyb项目中的Scintillation类。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Wed, 27 Jul 2011 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2011-07-27:photon-sim-promote.html</guid><category>模拟</category><category>geant4</category><category>物理</category></item><item><title>代码高亮测试</title><link>zsneoks.github.com/script-high.html</link><description>&lt;p&gt;如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;”foo”&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Hello World!&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s2"&gt;n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nb"&gt;tell&lt;/span&gt; &lt;span class="n"&gt;application&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Foo&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;beep&lt;/span&gt;
            &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="nb"&gt;tell&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Wed, 27 Jul 2011 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2011-07-27:script-high.html</guid><category>test</category></item><item><title>another test</title><link>zsneoks.github.com/test1.html</link><description>&lt;p&gt;So, you know this is a test post.&lt;/p&gt;
&lt;p&gt;this is a test for code&lt;/p&gt;
&lt;p&gt;c++:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
   &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello world!&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is &lt;a href="http://example.com/" title="Title"&gt;an example&lt;/a&gt; inline link.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://example.net/"&gt;This link&lt;/a&gt; has no title attribute.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Wed, 27 Jul 2011 00:00:00 +0800</pubDate><guid>tag:zsneoks.github.com,2011-07-27:test1.html</guid><category>test</category></item><item><title>关于</title><link>zsneoks.github.com/aboutme-htmlname.html</link><description>&lt;p&gt;我是一个粒子物理专业的研究生，目前在中国科学院的高能所学习，主要在一些实验中参加一些软件工作。&lt;/p&gt;
&lt;p&gt;我喜欢linux，热爱编程，对人工智能相关的兴趣堪比我对基础物理学的热情，纯理科男。&lt;/p&gt;
&lt;p&gt;欢迎在相关领域有兴趣的一起来交流。&lt;/p&gt;
&lt;p&gt;我的对外联系mail: &lt;a href="mailto:zsneoks@gmail.com"&gt;zsneoks@gmail.com&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">木大</dc:creator><pubDate>Tue, 01 Jan 1901 00:00:00 +0806</pubDate><guid>tag:zsneoks.github.com,1901-01-01:aboutme-htmlname.html</guid></item></channel></rss>